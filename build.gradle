apply plugin: 'maven'
apply plugin: 'java'
apply plugin: 'war'
//apply plugin: 'eclipse'
//apply plugin: 'eclipse-wtp'

sourceCompatibility = 1.7

repositories {
    mavenCentral()
}

dependencies{
    
    compile project(":gradle-sub-2")
    // 特别注意，如果直接用 gradle 命令行进行构建，下面这样是完全可以注释的，Gradle 会通过项目之间的引用关系而将 gradle-sub-1 工程打包
    // 但是 eclipse 构建打包的时候，并不会因为 sub-2 引用了 sub-1 而将 sub-1 进行打包并发布。
    // 所以，如果要想兼容 eclipse 和 gradle 命令行打包的方式，下面这行是必须加上的。
    compile project(":gradle-sub-1")
    
    compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
    
    providedRuntime 'javax.servlet:jsp-api:2.0' // 表示只是在运行时刻需要，而且在打包的时候，需要过滤掉。
    providedRuntime 'javax.servlet:servlet-api:2.5'
}


// 把编译后生成的文件拷贝到build目录中去
processResources{

	// 利用命令行和用户自定义参数的方式
	// gradle -q clean war // 表示进行本地构建
	// gradle -q -Pbuild=dev clean war //表示进行 dev 构建
	// gradle -q -Pbuild=release clean war // 表示进行 prod 构建
	
	// 用 dev 目录下的文件进行覆盖	
	if( build == 'dev'){ 
		
		from file('src/main/resources/dev/database.properties')
		from file('src/main/resources/dev/dev.specific')
		
		into sourceSets.main.output.resourcesDir
		
	}
	
	// 用 prod 目录下的文件进行覆盖
	if( build == 'prod'){
	
		from file('src/main/resources/dev/database.properties')
		from file('src/main/resources/dev/dev.specific')
		
		into sourceSets.main.output.resourcesDir
	
	}
	
	// 默认 build 为 null，即为 local build
	// gradle 执行到这里，发现需要 exclude，那么有两种方式可以处理，1、在拷贝的时候就 exclude 2、在拷贝完了以后再删除
	// 我觉得应该是 #2，因为从上面两个 if 逻辑可以猜测出来，local -> database.properties 并没有被 exclude，那么就意味着它一定会被被拷贝过来；既然
	// local -> database.properties 被拷贝了过来，那么只能被 prod / dev -> database.properties 进行覆盖，那么才可以得到我们预期的 dev/prod 环境
	// 所对应的文件；所以，这里的 processResources 的执行逻辑一定是
	// void processResources(){
	// 		super.processResources();
	// 		your defined logic 
	//}
	
	if( build != null ){
		
		// tips: if the file under source folder such as src/main/resources.. direct uses the filename
		exclude("local.specific") 
	
	}		
	
}

// tar 任务，为静态资源单独打包 
// 默认，生成 gradle-root.tar 到 build/distributions/gradle-root.tar，可通过 baseName 进行自定义
task tarStatic(type:Tar){
	
	from 'src/main/webapp/resources'
	
	baseName = 'resources'
	
}

println tarStatic.archiveName

war{
	// 为什么不用 build != null，试过，war 任务中不成功，还不知道原因
	if( build == 'dev' || build == 'prod' ){
		
		// First step, tar the static resources
		dependsOn( tarStatic )
		
		// Second Step, excludes the static resources
		// remember, dont uses resources/* as the argument, or else it will leaves the ugly folder for u.
		rootSpec.exclude("resources") 
		
	}
}

subprojects {

	apply plugin: 'maven'	
	apply plugin: 'java'
	//apply plugin: 'eclipse'
	//apply plugin: 'eclipse-wtp'

	sourceCompatibility = 1.7

    repositories {
       mavenCentral()
    }

    dependencies {
        compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
        testCompile 'junit:junit:4.8.2'
    }

    version = '1.0'

    jar {
        manifest.attributes provider: 'my cool company'
    }
    
}
